<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>烟花</title>
        <style>
            body {
                margin: 0;
                background-color: #000;
            }

            canvas {
                display: block;
            }
        </style>
    </head>

    <body>
        <canvas id="canvas"></canvas>
        <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.js"></script>
        <script type="module">
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;

            // canvas全屏
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // 设置发射点
            const shootPoint = {
                x: Math.ceil(canvasWidth / 2),
                y: canvasHeight
            };
            const point = _.cloneDeep(shootPoint);

            const friction = 9.8; // 向上空气的阻力，其实也是模拟重力

            // 获取范围内的随机数
            function randomRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            // 模拟初始速度
            function mockOriginalSpeed(h) {
                return Math.floor(Math.sqrt(2 * friction * h));
            }

            // 获取hue
            function getHue() {
                let hue = Math.random() * 360;
                let hueVariance = 200;
                return Math.floor(Math.random() * (hue + hueVariance - (hue - hueVariance))) + (hue - hueVariance);
            }

            let speed = mockOriginalSpeed(randomRange(canvasHeight * 0.7, canvasHeight));
            let hue = getHue();
            let brightness = randomRange(60, 70);
            let alpha = 1;
            let alphaDecay = randomRange(0.015, 0.03);

            function renderCanvas() {
                ctx.globalCompositeOperation = 'destination-out'; // 现有内容保持在新图形不重叠的地方
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.globalCompositeOperation = 'lighter';

                // 开始绘制
                const distance = speed - 0.5 * friction;
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point.x, point.y - distance + 2);
                ctx.lineCap = 'round';
                ctx.strokeStyle = `hsla(${hue}, 100%, ${brightness}%,${alpha})`; // 仅亮度会变化
                ctx.lineWidth = 2;
                ctx.stroke();

                // 速度应该是逐级递减的
                speed -= friction;
                alpha -= alphaDecay;
                point.y -= distance;

                if (speed < 0) {
                    return;
                    point.y = canvasHeight;
                    speed = mockOriginalSpeed(randomRange(canvasHeight / 2, canvasHeight));
                    hue = getHue();;
                    brightness = randomRange(60, 70);
                    alpha = 1;
                    alphaDecay = randomRange(0.015, 0.03);
                }
                requestAnimationFrame(renderCanvas);
            }

            renderCanvas();
        </script>
    </body>
</html>
